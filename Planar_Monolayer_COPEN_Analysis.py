from fileinput import filename
from posixpath import split
from statistics import stdev
import time as tt
import re
import os.path
import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate
import csv

###### Algorithm followed for quantative analysis in this script
###### Read report file generated by Abaqus
###### Extract copen data and store them in dictionaries 
###### copen_dict[time] = [instanceName nodeNumber cOpen]

#Find bi-cellular and tri-cellular instance nodes
instanceNameArray = []
biCellularNodeNumberArray = []
instanceBiCellularNodeArray = []
instanceTriCellularNodeArray = []

biCellularNodesFile = "bicellular_instance_nodes_3D_Mesh_1"
fbiCellular = open(biCellularNodesFile,"r")

triCellularNodesFile = "tricellular_instance_nodes_3D_Mesh_1"
ftriCellular = open(triCellularNodesFile,"r")

for line in fbiCellular:
    for i in range(int(len(line.split())/2)):
        if (i==0):
            currInstanceName = re.findall('\[\[\'(.*)\'',line.split()[i*2])[0]
        else:
            currInstanceName = re.findall('\[\'(.*)\'',line.split()[i*2])[0]

        if (i==int(len(line.split())/2)-1):
            currNodeNumber = re.findall('(.*)\]\]',line.split()[(i*2)+1])[0]
        else:
            currNodeNumber = re.findall('(.*)\]',line.split()[(i*2)+1])[0]
                
        instanceBiCellularNodeArray.append(currInstanceName+"---"+currNodeNumber)

#This section combines instanceName and nodeNumber in a particular format for all the tricellualr nodes
for line in ftriCellular:
    for i in range(int(len(line.split())/2)):
        if (i==0):
            currInstanceName = re.findall('\[\[\'(.*)\'',line.split()[i*2])[0]
        else:
            currInstanceName = re.findall('\[\'(.*)\'',line.split()[i*2])[0]

        if (i==int(len(line.split())/2)-1):
            currNodeNumber = re.findall('(.*)\]\]',line.split()[(i*2)+1])[0]
        else:
            currNodeNumber = re.findall('(.*)\]',line.split()[(i*2)+1])[0]
                
        instanceTriCellularNodeArray.append(currInstanceName+"---"+currNodeNumber)

ntotalJunctions = len(instanceBiCellularNodeArray) + len(instanceTriCellularNodeArray)
nBiCellularJunctions = len(instanceBiCellularNodeArray)
nTricellularJunctions = len(instanceTriCellularNodeArray)

def isfloat(num):
    try:
        float(num)
        return True
    except ValueError:
        return False

####Read csv files
leakRatioBiCellularJunctionDict = {}
leakRatioTriCellularJunctionDict = {}
instabilityParameterBiCellularJunctionDict = {}
instabilityParameterTriCellularJunctionDict = {}

for jj in range(1,2):
#   name of the report file stored in csv format
    if jj==1:
        filename_part = "name_of_report_file"
    
    for ii in range(1,2):
        oldIncrement = 0.0
        filename_CNormf = filename_part+"_"+str(ii)+".csv"
        with open(filename_CNormf, mode='r') as csv_NormF:
            print(filename_CNormf)  
            csv_reader_NormF = csv.DictReader(csv_NormF)

            nBiCellularJunctions_CSV = 0
            nTriCellularJunctions_CSV = 0
            nopenBicellularJunctionDict = {}
            nopenTricellularJunctionDict = {}
            cOpenBicellularJunctionDict = {}
            cOpenTricellularJunctionDict = {}
            cOpenValueBiCellularJunctionDict = {}
            cOpenValueTriCellularJunctionDict = {}
            avgCOpenValueBiCellularJunction = {}
            avgCOpenValueTriCellularJunction = {}
            currTimeOld = 0.0
            timeArray = []
            timeArray1 = []
            timeArray.append(currTimeOld)
            maxCOpenBiCellularJunction = {}
            maxCOpenTriCellularJunction = {}
            iter = 0
            t_start = 18.0    # steady state analysis is performed for last 2 seconds
            
            for row in csv_reader_NormF:
                iter = iter + 1
                ODB_Name = row['ODB Name']
                if currTimeOld <= 20:           #time for which abaqus analysis is run (this needs to be changed if abaqus analysis is run for different end time)
                    if ODB_Name == 'ODB Name':
                        continue
                    currFrame = row[list(row.keys())[2]]
                    currTime = currFrame.split()[-1]
                    currIncrement = currFrame.split()[1].rstrip(':')
                    InstanceName = row[list(row.keys())[3]]
                    NodeNum = row[list(row.keys())[6]].strip()
                    if isfloat(row[list(row.keys())[-1]]) is True:
                        Copen = float(row[list(row.keys())[-1]])
                    else:
                        continue

                    currNodeInstance = InstanceName+"---"+NodeNum
                    
                    currTimeNew = float(currTime)
                    deltaIncrement = float(currIncrement) - float(oldIncrement)
                    deltaTimeStep =  currTimeNew - currTimeOld

                    if  (deltaIncrement > 0.0) :
                        nopenBicellularJunction = 0
                        nopenTricellularJunction = 0
                        
                        currTimeOld = currTimeNew  
                        timeArray.append(currTimeOld)
                        oldIncrement = currIncrement

                    if (deltaIncrement > 0) and (deltaTimeStep == 0):
                        if currTime in cOpenBicellularJunctionDict:
                            cOpenBicellularJunctionDict.pop(currTime)
                        if currTime in cOpenTricellularJunctionDict:
                            cOpenTricellularJunctionDict.pop(currTime)

                    if currNodeInstance in instanceBiCellularNodeArray:
                        
                        if currTimeNew == 0.0:
                            nBiCellularJunctions_CSV += 1
                            
                        if Copen >= 0.15:       # copen threshold (set this value to the desired threshold)
                            if currTimeNew > t_start and currTime in cOpenBicellularJunctionDict:
                                cOpenBicellularJunctionDict[currTime].append(currNodeInstance)
                            elif currTimeNew > t_start: 
                                cOpenBicellularJunctionDict[currTime] = [currNodeInstance]

                    if currNodeInstance in instanceTriCellularNodeArray:
                        if currTimeNew == 0.0:
                            nTriCellularJunctions_CSV += 1
                            
                        if Copen >= 0.15:
                            if currTimeNew > t_start and currTime in cOpenTricellularJunctionDict:
                                cOpenTricellularJunctionDict[currTime].append(currNodeInstance)
                            elif currTimeNew > t_start:
                                cOpenTricellularJunctionDict[currTime] = [currNodeInstance]

        for key in cOpenBicellularJunctionDict.keys():
            nopenBicellularJunctionDict[key] = [nBiCellularJunctions_CSV,len(cOpenBicellularJunctionDict[key])]
        for key in cOpenTricellularJunctionDict.keys():
            nopenTricellularJunctionDict[key] = [nTriCellularJunctions_CSV,len(cOpenTricellularJunctionDict[key])]

        ###Evaluate leak ratio (or permeability)
        leakRatioBiCellularJunctionArray = []
        leakRatioTriCellularJunctionArray = []

        leakRatioBiCellularJunctionSmallDict = {}
        leakRatioTriCellularJunctionSmallDict = {}

        for key in nopenBicellularJunctionDict.keys():
            leakRatioBiCellularJunctionSmallDict[float(key)] = list(nopenBicellularJunctionDict[key])[1]/(list(nopenBicellularJunctionDict[key])[0])

        for key in nopenTricellularJunctionDict.keys():    
            leakRatioTriCellularJunctionSmallDict[float(key)] = list(nopenTricellularJunctionDict[key])[1]/(list(nopenTricellularJunctionDict[key])[0])

        leakRatioBiCellularJunctionDict[ii] = leakRatioBiCellularJunctionSmallDict
        leakRatioTriCellularJunctionDict[ii] = leakRatioTriCellularJunctionSmallDict

    # ##### timeArrayforInterpolation (interpolation done to have same time steps in all analyses)
    endTime = float(timeArray[-1])
    interpTimeArray = np.arange(t_start,endTime,0.001)

    interpBiCellularLeakRatioDict = {}
    interpTriCellularLeakRatioDict = {}

    for outerKey in leakRatioBiCellularJunctionDict.keys():                                           ## loop over rpt file names  (BigDictKey)
        
        leakRatioBiCellularJunctionArray = []
        leakRatioTriCellularJunctionArray = []
        leakRatioBiCellularTimeArray = []
        leakRatioTriCellularTimeArray = []

        for innerKey in leakRatioBiCellularJunctionDict[outerKey].keys():                             ## loop over time
            
            leakRatioBiCellularTimeArray.append(innerKey)                                             ## store original time instances in an array 
            leakRatioBiCellularJunctionArray.append(leakRatioBiCellularJunctionDict[outerKey][innerKey])
        
        for innerKey in leakRatioTriCellularJunctionDict[outerKey].keys():
            leakRatioTriCellularTimeArray.append(innerKey)
            leakRatioTriCellularJunctionArray.append(leakRatioTriCellularJunctionDict[outerKey][innerKey])
            
        f2 = interpolate.interp1d(leakRatioBiCellularTimeArray, leakRatioBiCellularJunctionArray,fill_value='extrapolate')    ## generate interpolation function
        interpLeakBiCellularJunctionsArray = f2(interpTimeArray)                                         ## generate interpolated data over chosen time array

        f3 = interpolate.interp1d(leakRatioTriCellularTimeArray, leakRatioTriCellularJunctionArray,fill_value='extrapolate')    ## generate interpolation function
        interpLeakTriCellularJunctionsArray = f3(interpTimeArray)                                         ## generate interpolated data over chosen time array

        interpBiCellularLeakRatioSmallDict = {}
        interpTriCellularLeakRatioSmallDict = {}
        for i in range(len(interpTimeArray)):
            key = interpTimeArray[i]
            interpBiCellularLeakRatioSmallDict[key] = interpLeakBiCellularJunctionsArray[i]
            interpTriCellularLeakRatioSmallDict[key] = interpLeakTriCellularJunctionsArray[i]


    ##### Update interpleakRatioDict with interpolated leakratio array for each simulation file     
        interpBiCellularLeakRatioDict[outerKey] = interpBiCellularLeakRatioSmallDict                         
        interpTriCellularLeakRatioDict[outerKey] = interpTriCellularLeakRatioSmallDict                         

    ##### Having data of each simulation over the interpTimeArray..now we sort the data according to time for each simulation 
    ##### so that average over different simulations at a given time instance can be taken. 

    timeSortedBiCellularLeakRatioDict = {}
    timeSortedTriCellularLeakRatioDict = {}

    for j in interpTimeArray:
        for key in interpBiCellularLeakRatioDict.keys():
            timeSortedKey = j
            if timeSortedKey in timeSortedBiCellularLeakRatioDict.keys():
                timeSortedBiCellularLeakRatioDict[timeSortedKey].append(interpBiCellularLeakRatioDict[key][j])    ## update leak percentage parameter data for each simulation file for a given time instance
                timeSortedTriCellularLeakRatioDict[timeSortedKey].append(interpTriCellularLeakRatioDict[key][j])  ## update leak percentage parameter data for each simulation file for a given time instance
            else:
                timeSortedBiCellularLeakRatioDict[timeSortedKey] = [interpBiCellularLeakRatioDict[key][j]]
                timeSortedTriCellularLeakRatioDict[timeSortedKey]= [interpTriCellularLeakRatioDict[key][j]]

        for key in interpTriCellularLeakRatioDict.keys():
            timeSortedKey = j
            if timeSortedKey in timeSortedTriCellularLeakRatioDict.keys():
                timeSortedTriCellularLeakRatioDict[timeSortedKey].append(interpTriCellularLeakRatioDict[key][j])   ## update leak percentage parameter data for each simulation file for a given time instance
            else:
                timeSortedTriCellularLeakRatioDict[timeSortedKey]= [interpTriCellularLeakRatioDict[key][j]]

    ##### Evaluate mean and std dev for each time instance (Over simulations)

    meanLeakRatioBiCellularJunctionsArray = []
    stdevLeakRatioBiCellularJunctionsArray = []
    meanLeakRatioTriCellularJunctionsArray = []
    stdevLeakRatioTriCellularJunctionsArray = []

    for key in timeSortedBiCellularLeakRatioDict.keys():
        meanLeakRatioBiCellularJunctionsArray.append(np.mean(timeSortedBiCellularLeakRatioDict[key]))
        stdevLeakRatioBiCellularJunctionsArray.append(stdev(timeSortedBiCellularLeakRatioDict[key]))    

    for key in timeSortedTriCellularLeakRatioDict.keys():
        meanLeakRatioTriCellularJunctionsArray.append(np.mean(timeSortedTriCellularLeakRatioDict[key]))
        stdevLeakRatioTriCellularJunctionsArray.append(stdev(timeSortedTriCellularLeakRatioDict[key]))    

    data = np.column_stack([interpTimeArray, meanLeakRatioBiCellularJunctionsArray,stdevLeakRatioBiCellularJunctionsArray])
    datafile_path = "./LeakRatio_BiCellular_"+filename_part+"_0_15.txt"
    np.savetxt(datafile_path , data, fmt=['%e','%e','%e'])

    data = np.column_stack([interpTimeArray, meanLeakRatioTriCellularJunctionsArray,stdevLeakRatioTriCellularJunctionsArray])
    datafile_path = "./LeakRatio_TriCellular_"+filename_part+"_0_15.txt"
    np.savetxt(datafile_path , data, fmt=['%e','%e','%e'])

    fig, ax = plt.subplots()
    ax.plot(interpTimeArray,meanLeakRatioBiCellularJunctionsArray , '-',label="Leak ratio bicellular")
    ax.plot(interpTimeArray,meanLeakRatioTriCellularJunctionsArray , '-',label="Leak ratio tricellular")
    ax.fill_between(interpTimeArray, np.subtract(meanLeakRatioBiCellularJunctionsArray,stdevLeakRatioBiCellularJunctionsArray), np.add(meanLeakRatioBiCellularJunctionsArray,stdevLeakRatioBiCellularJunctionsArray), alpha=0.2)
    ax.fill_between(interpTimeArray, np.subtract(meanLeakRatioTriCellularJunctionsArray,stdevLeakRatioTriCellularJunctionsArray), np.add(meanLeakRatioTriCellularJunctionsArray,stdevLeakRatioTriCellularJunctionsArray), alpha=0.2)
    plt.xlabel("time(s)")
    plt.ylabel("Leak ratio")
    plt.legend()
    figname = filename_part+"_0_15.png"
    plt.savefig(figname)